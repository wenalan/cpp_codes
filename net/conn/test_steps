精准造状态：iptables/nft + ss/tcpdump 套餐（建议用 netns 在一台机器模拟两台）

你说“需要”，那我给你一套可以反复开关、稳定停住状态的实验。

4.1 先建两个 network namespace（同机模拟两台）
sudo ip netns add nsC
sudo ip netns add nsS
sudo ip link add vethC type veth peer name vethS
sudo ip link set vethC netns nsC
sudo ip link set vethS netns nsS
sudo ip -n nsC addr add 10.200.1.1/24 dev vethC
sudo ip -n nsS addr add 10.200.1.2/24 dev vethS
sudo ip -n nsC link set lo up
sudo ip -n nsS link set lo up
sudo ip -n nsC link set vethC up
sudo ip -n nsS link set vethS up


观测窗口（强烈建议一直开着）：

watch -n 0.2 "sudo ip netns exec nsC ss -tanp; echo '---'; sudo ip netns exec nsS ss -tanp"


抓包：

sudo ip netns exec nsC tcpdump -i vethC -nn -tttt -vv -S 'tcp port 8080'


运行你前面那套 server.py/client.py：

sudo ip netns exec nsS python3 server.py 8080 normal
sudo ip netns exec nsC python3 client.py 10.200.1.2 8080 normal

4.2 精准制造 SYN-SENT / SYN-RECV（丢掉 SYN-ACK）

目标：让 client 卡在 SYN-SENT，server 卡在 SYN-RECV。

在 client namespace 丢掉从 server 来的 SYN-ACK：

sudo ip netns exec nsC iptables -I INPUT -p tcp --sport 8080 --tcp-flags SYN,ACK SYN,ACK -j DROP


然后在 nsC 发起连接（client 会一直重传 SYN）：

sudo ip netns exec nsC python3 client.py 10.200.1.2 8080 normal


你会看到：

nsC：SYN-SENT

nsS：SYN-RECV

清理规则：

sudo ip netns exec nsC iptables -D INPUT -p tcp --sport 8080 --tcp-flags SYN,ACK SYN,ACK -j DROP

4.3 精准制造“半开”：server 停在 SYN-RECV，但 client 显示 ESTABLISHED（丢掉第三次握手 ACK）

目标：server 卡在 SYN-RECV，client 可能显示 ESTABLISHED（典型半开连接观测）。

在 client namespace 丢掉“纯 ACK（无 SYN/FIN/RST/PSH）”发往 server 的包（第三次握手就是 ACK-only）：

sudo ip netns exec nsC iptables -I OUTPUT -p tcp -d 10.200.1.2 --dport 8080 \
  --tcp-flags SYN,ACK,FIN,RST,PSH ACK -j DROP


运行 client（建议不要立刻发数据，先只 connect 并 sleep，便于观测）：

你可以把 client.py 改成 connect 后先 time.sleep(999)，不 send。

清理规则：

sudo ip netns exec nsC iptables -D OUTPUT -p tcp -d 10.200.1.2 --dport 8080 \
  --tcp-flags SYN,ACK,FIN,RST,PSH ACK -j DROP

4.4 精准制造 TIME-WAIT（主动关闭方）

让 client 主动 close：

sudo ip netns exec nsS python3 server.py 8080 normal
sudo ip netns exec nsC python3 client.py 10.200.1.2 8080 close_first


只看 TIME-WAIT：

sudo ip netns exec nsC ss -tan state time-wait

4.5 精准制造 RST（两种最直观的办法）
A) 连接不存在端口（看到 RST→Connection refused）
sudo ip netns exec nsC python3 client.py 10.200.1.2 9999 normal


抓包里会看到 RST（通常是 server 回的）。

B) client 用 SO_LINGER=0 发 abortive close（你脚本的 rst 模式）
sudo ip netns exec nsS python3 server.py 8080 normal
sudo ip netns exec nsC python3 client.py 10.200.1.2 8080 rst


只抓 RST：

sudo ip netns exec nsC tcpdump -i vethC -nn -vv 'tcp port 8080 and (tcp[tcpflags] & tcp-rst != 0)'